'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _d3Selection = require('d3-selection');

var d3Selection = _interopRequireWildcard(_d3Selection);

var _pureRenderComponent = require('../pure-render-component');

var _pureRenderComponent2 = _interopRequireDefault(_pureRenderComponent);

var _reactUtils = require('../utils/react-utils');

var _axisUtils = require('../utils/axis-utils');

var _scalesUtils = require('../utils/scales-utils');

var _animationUtils = require('../utils/animation-utils');

var _theme = require('../theme');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * Get axis component for the chart/plot.
 * @param {string} displayName Display name for the component.
 * @param {string} classSet Class name postfix for the axis container.
 * @param {string} orientation d3's orientation.
 * @param {function(Number, Number, Object):Number} tickNumberCallback Callback
 *   to calculate the number of ticks passed.
 * @returns {React.Component} Axis component.
 */
var Axis = function (_PureRenderComponent) {
  _inherits(Axis, _PureRenderComponent);

  function Axis() {
    _classCallCheck(this, Axis);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Axis).apply(this, arguments));
  }

  _createClass(Axis, [{
    key: '_setAxisLabels',


    /**
     * Set axis labels.
     * @param {Object} axis Axis object.
     * @returns {Object} Axis object.
     * @private
     */
    value: function _setAxisLabels(axis) {
      var _props = this.props;
      var labelFormat = _props.labelFormat;
      var labelValues = _props.labelValues;
      var ticksTotal = _props.ticksTotal;

      if (!labelValues) {
        axis.ticks(ticksTotal);
      } else {
        axis.tickValues(labelValues);
      }
      if (labelFormat) {
        axis.tickFormat(labelFormat);
      }
      axis.tickSize(0, 0);
      axis.tickSizeOuter(0);
      axis.tickPadding(14);
      return axis;
    }

    /**
     * Set axis ticks.
     * @param {Object} axis Axis object.
     * @returns {Object} Axis object.
     * @private
     */

  }, {
    key: '_setAxisTicks',
    value: function _setAxisTicks(axis) {
      var _props2 = this.props;
      var tickValues = _props2.tickValues;
      var ticksTotal = _props2.ticksTotal;
      var tickSize = _props2.tickSize;

      if (!tickValues) {
        axis.ticks(ticksTotal);
      } else {
        axis.tickValues(tickValues);
      }
      axis.tickFormat('');
      axis.tickSize(tickSize);
      axis.tickSizeOuter(0);
      return axis;
    }

    /**
     * Renders the axis inside the existing container.
     * @private
     */

  }, {
    key: '_render',
    value: function _render() {
      var _props3 = this.props;
      var orientation = _props3.orientation;
      var attr = _props3.attr;

      var scale = (0, _scalesUtils.getAttributeScale)(this.props, attr);
      if (!scale) {
        return;
      }

      var _refs = this.refs;
      var labels = _refs.labels;
      var ticks = _refs.ticks;

      var selectedLabels = d3Selection.select((0, _reactUtils.getDOMNode)(labels));
      var selectedTicks = d3Selection.select((0, _reactUtils.getDOMNode)(ticks));
      var axisFn = (0, _axisUtils.getAxisFnByOrientation)(orientation);
      var axis = this._setAxisLabels(axisFn(scale));

      (0, _animationUtils.applyTransition)(this.props, selectedLabels).call(this._setAxisLabels(axis));
      (0, _animationUtils.applyTransition)(this.props, selectedTicks).call(this._setAxisTicks(axis));
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._render();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this._render();
    }
  }, {
    key: 'render',
    value: function render() {
      var _props4 = this.props;
      var title = _props4.title;
      var left = _props4.left;
      var top = _props4.top;
      var className = _props4.className;

      var hasTitle = title && title !== '';
      return _react2.default.createElement(
        'g',
        { className: 'rv-xy-plot__axis ' + className,
          transform: 'translate(' + left + ',' + top + ')',
          ref: 'container' },
        _react2.default.createElement('g', {
          ref: 'labels',
          className: 'rv-xy-plot__axis__labels' }),
        _react2.default.createElement('g', {
          ref: 'ticks',
          className: 'rv-xy-plot__axis__ticks' }),
        hasTitle ? _react2.default.createElement(
          'g',
          {
            className: 'rv-xy-plot__axis__title',
            style: this.props.titleStyle },
          _react2.default.createElement(
            'text',
            null,
            title
          )
        ) : null
      );
    }
  }], [{
    key: 'propTypes',
    get: function get() {
      return {
        title: _react2.default.PropTypes.string,
        classSet: _react2.default.PropTypes.object,
        attr: _react2.default.PropTypes.string.isRequired,
        orientation: _react2.default.PropTypes.oneOf(_axisUtils.AXIS_ORIENTATIONS),
        labelFormat: _react2.default.PropTypes.func,
        labelValues: _react2.default.PropTypes.array,
        tickValues: _react2.default.PropTypes.array,
        ticksTotal: _react2.default.PropTypes.number,
        tickSize: _react2.default.PropTypes.number,
        animation: _animationUtils.AnimationPropType
      };
    }
  }, {
    key: 'defaultProps',
    get: function get() {
      return {
        tickSize: _theme.DEFAULT_TICK_SIZE
      };
    }
  }, {
    key: 'requiresSVG',
    get: function get() {
      return true;
    }
  }]);

  return Axis;
}(_pureRenderComponent2.default);

Axis.displayName = 'Axis';

exports.default = Axis;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvcGxvdC9heGlzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBb0JBOzs7O0FBQ0E7O0lBQVksVzs7QUFFWjs7OztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7OytlQTlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFjQTs7Ozs7Ozs7O0lBU00sSTs7Ozs7Ozs7Ozs7OztBQTJCSjs7Ozs7O21DQU1lLEksRUFBTTtBQUFBLG1CQUM0QixLQUFLLEtBRGpDO0FBQUEsVUFDWixXQURZLFVBQ1osV0FEWTtBQUFBLFVBQ0MsV0FERCxVQUNDLFdBREQ7QUFBQSxVQUNjLFVBRGQsVUFDYyxVQURkOztBQUVuQixVQUFJLENBQUMsV0FBTCxFQUFrQjtBQUNoQixhQUFLLEtBQUwsQ0FBVyxVQUFYO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBSyxVQUFMLENBQWdCLFdBQWhCO0FBQ0Q7QUFDRCxVQUFJLFdBQUosRUFBaUI7QUFDZixhQUFLLFVBQUwsQ0FBZ0IsV0FBaEI7QUFDRDtBQUNELFdBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakI7QUFDQSxXQUFLLGFBQUwsQ0FBbUIsQ0FBbkI7QUFDQSxXQUFLLFdBQUwsQ0FBaUIsRUFBakI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O2tDQU1jLEksRUFBTTtBQUFBLG9CQUN5QixLQUFLLEtBRDlCO0FBQUEsVUFDWCxVQURXLFdBQ1gsVUFEVztBQUFBLFVBQ0MsVUFERCxXQUNDLFVBREQ7QUFBQSxVQUNhLFFBRGIsV0FDYSxRQURiOztBQUVsQixVQUFJLENBQUMsVUFBTCxFQUFpQjtBQUNmLGFBQUssS0FBTCxDQUFXLFVBQVg7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLLFVBQUwsQ0FBZ0IsVUFBaEI7QUFDRDtBQUNELFdBQUssVUFBTCxDQUFnQixFQUFoQjtBQUNBLFdBQUssUUFBTCxDQUFjLFFBQWQ7QUFDQSxXQUFLLGFBQUwsQ0FBbUIsQ0FBbkI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs4QkFJVTtBQUFBLG9CQUNvQixLQUFLLEtBRHpCO0FBQUEsVUFDRCxXQURDLFdBQ0QsV0FEQztBQUFBLFVBQ1ksSUFEWixXQUNZLElBRFo7O0FBRVIsVUFBTSxRQUFRLG9DQUFrQixLQUFLLEtBQXZCLEVBQThCLElBQTlCLENBQWQ7QUFDQSxVQUFJLENBQUMsS0FBTCxFQUFZO0FBQ1Y7QUFDRDs7QUFMTyxrQkFPZ0IsS0FBSyxJQVByQjtBQUFBLFVBT0QsTUFQQyxTQU9ELE1BUEM7QUFBQSxVQU9PLEtBUFAsU0FPTyxLQVBQOztBQVFSLFVBQU0saUJBQWlCLFlBQVksTUFBWixDQUFtQiw0QkFBVyxNQUFYLENBQW5CLENBQXZCO0FBQ0EsVUFBTSxnQkFBZ0IsWUFBWSxNQUFaLENBQW1CLDRCQUFXLEtBQVgsQ0FBbkIsQ0FBdEI7QUFDQSxVQUFNLFNBQVMsdUNBQXVCLFdBQXZCLENBQWY7QUFDQSxVQUFNLE9BQU8sS0FBSyxjQUFMLENBQW9CLE9BQU8sS0FBUCxDQUFwQixDQUFiOztBQUVBLDJDQUFnQixLQUFLLEtBQXJCLEVBQTRCLGNBQTVCLEVBQ0csSUFESCxDQUNRLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQURSO0FBRUEsMkNBQWdCLEtBQUssS0FBckIsRUFBNEIsYUFBNUIsRUFDRyxJQURILENBQ1EsS0FBSyxhQUFMLENBQW1CLElBQW5CLENBRFI7QUFFRDs7O3dDQUVtQjtBQUNsQixXQUFLLE9BQUw7QUFDRDs7O3lDQUVvQjtBQUNuQixXQUFLLE9BQUw7QUFDRDs7OzZCQUVRO0FBQUEsb0JBQytCLEtBQUssS0FEcEM7QUFBQSxVQUNBLEtBREEsV0FDQSxLQURBO0FBQUEsVUFDTyxJQURQLFdBQ08sSUFEUDtBQUFBLFVBQ2EsR0FEYixXQUNhLEdBRGI7QUFBQSxVQUNrQixTQURsQixXQUNrQixTQURsQjs7QUFFUCxVQUFNLFdBQVcsU0FBUyxVQUFVLEVBQXBDO0FBQ0EsYUFDRTtBQUFBO0FBQUEsVUFBRyxpQ0FBK0IsU0FBbEM7QUFDRyxvQ0FBd0IsSUFBeEIsU0FBZ0MsR0FBaEMsTUFESDtBQUVHLGVBQUksV0FGUDtBQUdFO0FBQ0UsZUFBSSxRQUROO0FBRUUscUJBQVUsMEJBRlosR0FIRjtBQU1FO0FBQ0UsZUFBSSxPQUROO0FBRUUscUJBQVUseUJBRlosR0FORjtBQVNHLG1CQUNDO0FBQUE7QUFBQTtBQUNFLHVCQUFVLHlCQURaO0FBRUUsbUJBQU8sS0FBSyxLQUFMLENBQVcsVUFGcEI7QUFHRTtBQUFBO0FBQUE7QUFBTztBQUFQO0FBSEYsU0FERCxHQU1DO0FBZkosT0FERjtBQW9CRDs7O3dCQXhIc0I7QUFDckIsYUFBTztBQUNMLGVBQU8sZ0JBQU0sU0FBTixDQUFnQixNQURsQjtBQUVMLGtCQUFVLGdCQUFNLFNBQU4sQ0FBZ0IsTUFGckI7QUFHTCxjQUFNLGdCQUFNLFNBQU4sQ0FBZ0IsTUFBaEIsQ0FBdUIsVUFIeEI7QUFJTCxxQkFBYSxnQkFBTSxTQUFOLENBQWdCLEtBQWhCLDhCQUpSO0FBS0wscUJBQWEsZ0JBQU0sU0FBTixDQUFnQixJQUx4QjtBQU1MLHFCQUFhLGdCQUFNLFNBQU4sQ0FBZ0IsS0FOeEI7QUFPTCxvQkFBWSxnQkFBTSxTQUFOLENBQWdCLEtBUHZCO0FBUUwsb0JBQVksZ0JBQU0sU0FBTixDQUFnQixNQVJ2QjtBQVNMLGtCQUFVLGdCQUFNLFNBQU4sQ0FBZ0IsTUFUckI7QUFVTDtBQVZLLE9BQVA7QUFZRDs7O3dCQUV5QjtBQUN4QixhQUFPO0FBQ0w7QUFESyxPQUFQO0FBR0Q7Ozt3QkFFd0I7QUFDdkIsYUFBTyxJQUFQO0FBQ0Q7Ozs7OztBQW9HSCxLQUFLLFdBQUwsR0FBbUIsTUFBbkI7O2tCQUVlLEkiLCJmaWxlIjoiYXhpcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBkM1NlbGVjdGlvbiBmcm9tICdkMy1zZWxlY3Rpb24nO1xuXG5pbXBvcnQgUHVyZVJlbmRlckNvbXBvbmVudCBmcm9tICcuLi9wdXJlLXJlbmRlci1jb21wb25lbnQnO1xuaW1wb3J0IHtnZXRET01Ob2RlfSBmcm9tICcuLi91dGlscy9yZWFjdC11dGlscyc7XG5pbXBvcnQge0FYSVNfT1JJRU5UQVRJT05TLCBnZXRBeGlzRm5CeU9yaWVudGF0aW9ufSBmcm9tICcuLi91dGlscy9heGlzLXV0aWxzJztcbmltcG9ydCB7Z2V0QXR0cmlidXRlU2NhbGV9IGZyb20gJy4uL3V0aWxzL3NjYWxlcy11dGlscyc7XG5cbmltcG9ydCB7QW5pbWF0aW9uUHJvcFR5cGUsIGFwcGx5VHJhbnNpdGlvbn0gZnJvbSAnLi4vdXRpbHMvYW5pbWF0aW9uLXV0aWxzJztcblxuaW1wb3J0IHtERUZBVUxUX1RJQ0tfU0laRX0gZnJvbSAnLi4vdGhlbWUnO1xuXG4vKipcbiAqIEdldCBheGlzIGNvbXBvbmVudCBmb3IgdGhlIGNoYXJ0L3Bsb3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGxheU5hbWUgRGlzcGxheSBuYW1lIGZvciB0aGUgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzU2V0IENsYXNzIG5hbWUgcG9zdGZpeCBmb3IgdGhlIGF4aXMgY29udGFpbmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudGF0aW9uIGQzJ3Mgb3JpZW50YXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE51bWJlciwgTnVtYmVyLCBPYmplY3QpOk51bWJlcn0gdGlja051bWJlckNhbGxiYWNrIENhbGxiYWNrXG4gKiAgIHRvIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHBhc3NlZC5cbiAqIEByZXR1cm5zIHtSZWFjdC5Db21wb25lbnR9IEF4aXMgY29tcG9uZW50LlxuICovXG5jbGFzcyBBeGlzIGV4dGVuZHMgUHVyZVJlbmRlckNvbXBvbmVudCB7XG5cbiAgc3RhdGljIGdldCBwcm9wVHlwZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpdGxlOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgY2xhc3NTZXQ6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgICBhdHRyOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICBvcmllbnRhdGlvbjogUmVhY3QuUHJvcFR5cGVzLm9uZU9mKEFYSVNfT1JJRU5UQVRJT05TKSxcbiAgICAgIGxhYmVsRm9ybWF0OiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICAgIGxhYmVsVmFsdWVzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgICB0aWNrVmFsdWVzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgICB0aWNrc1RvdGFsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLFxuICAgICAgdGlja1NpemU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gICAgICBhbmltYXRpb246IEFuaW1hdGlvblByb3BUeXBlXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0aWNrU2l6ZTogREVGQVVMVF9USUNLX1NJWkVcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCByZXF1aXJlc1NWRygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYXhpcyBsYWJlbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBheGlzIEF4aXMgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBeGlzIG9iamVjdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRBeGlzTGFiZWxzKGF4aXMpIHtcbiAgICBjb25zdCB7bGFiZWxGb3JtYXQsIGxhYmVsVmFsdWVzLCB0aWNrc1RvdGFsfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFsYWJlbFZhbHVlcykge1xuICAgICAgYXhpcy50aWNrcyh0aWNrc1RvdGFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpcy50aWNrVmFsdWVzKGxhYmVsVmFsdWVzKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsRm9ybWF0KSB7XG4gICAgICBheGlzLnRpY2tGb3JtYXQobGFiZWxGb3JtYXQpO1xuICAgIH1cbiAgICBheGlzLnRpY2tTaXplKDAsIDApO1xuICAgIGF4aXMudGlja1NpemVPdXRlcigwKTtcbiAgICBheGlzLnRpY2tQYWRkaW5nKDE0KTtcbiAgICByZXR1cm4gYXhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYXhpcyB0aWNrcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGF4aXMgQXhpcyBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEF4aXMgb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEF4aXNUaWNrcyhheGlzKSB7XG4gICAgY29uc3Qge3RpY2tWYWx1ZXMsIHRpY2tzVG90YWwsIHRpY2tTaXplfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCF0aWNrVmFsdWVzKSB7XG4gICAgICBheGlzLnRpY2tzKHRpY2tzVG90YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzLnRpY2tWYWx1ZXModGlja1ZhbHVlcyk7XG4gICAgfVxuICAgIGF4aXMudGlja0Zvcm1hdCgnJyk7XG4gICAgYXhpcy50aWNrU2l6ZSh0aWNrU2l6ZSk7XG4gICAgYXhpcy50aWNrU2l6ZU91dGVyKDApO1xuICAgIHJldHVybiBheGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGF4aXMgaW5zaWRlIHRoZSBleGlzdGluZyBjb250YWluZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyKCkge1xuICAgIGNvbnN0IHtvcmllbnRhdGlvbiwgYXR0cn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHNjYWxlID0gZ2V0QXR0cmlidXRlU2NhbGUodGhpcy5wcm9wcywgYXR0cik7XG4gICAgaWYgKCFzY2FsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtsYWJlbHMsIHRpY2tzfSA9IHRoaXMucmVmcztcbiAgICBjb25zdCBzZWxlY3RlZExhYmVscyA9IGQzU2VsZWN0aW9uLnNlbGVjdChnZXRET01Ob2RlKGxhYmVscykpO1xuICAgIGNvbnN0IHNlbGVjdGVkVGlja3MgPSBkM1NlbGVjdGlvbi5zZWxlY3QoZ2V0RE9NTm9kZSh0aWNrcykpO1xuICAgIGNvbnN0IGF4aXNGbiA9IGdldEF4aXNGbkJ5T3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLl9zZXRBeGlzTGFiZWxzKGF4aXNGbihzY2FsZSkpO1xuXG4gICAgYXBwbHlUcmFuc2l0aW9uKHRoaXMucHJvcHMsIHNlbGVjdGVkTGFiZWxzKVxuICAgICAgLmNhbGwodGhpcy5fc2V0QXhpc0xhYmVscyhheGlzKSk7XG4gICAgYXBwbHlUcmFuc2l0aW9uKHRoaXMucHJvcHMsIHNlbGVjdGVkVGlja3MpXG4gICAgICAuY2FsbCh0aGlzLl9zZXRBeGlzVGlja3MoYXhpcykpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge3RpdGxlLCBsZWZ0LCB0b3AsIGNsYXNzTmFtZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGhhc1RpdGxlID0gdGl0bGUgJiYgdGl0bGUgIT09ICcnO1xuICAgIHJldHVybiAoXG4gICAgICA8ZyBjbGFzc05hbWU9e2Bydi14eS1wbG90X19heGlzICR7Y2xhc3NOYW1lfWB9XG4gICAgICAgICB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHtsZWZ0fSwke3RvcH0pYH1cbiAgICAgICAgIHJlZj1cImNvbnRhaW5lclwiPlxuICAgICAgICA8Z1xuICAgICAgICAgIHJlZj1cImxhYmVsc1wiXG4gICAgICAgICAgY2xhc3NOYW1lPVwicnYteHktcGxvdF9fYXhpc19fbGFiZWxzXCIvPlxuICAgICAgICA8Z1xuICAgICAgICAgIHJlZj1cInRpY2tzXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJydi14eS1wbG90X19heGlzX190aWNrc1wiLz5cbiAgICAgICAge2hhc1RpdGxlID9cbiAgICAgICAgICA8Z1xuICAgICAgICAgICAgY2xhc3NOYW1lPVwicnYteHktcGxvdF9fYXhpc19fdGl0bGVcIlxuICAgICAgICAgICAgc3R5bGU9e3RoaXMucHJvcHMudGl0bGVTdHlsZX0+XG4gICAgICAgICAgICA8dGV4dD57dGl0bGV9PC90ZXh0PlxuICAgICAgICAgIDwvZz4gOlxuICAgICAgICAgIG51bGxcbiAgICAgICAgfVxuICAgICAgPC9nPlxuICAgICk7XG4gIH1cbn1cblxuQXhpcy5kaXNwbGF5TmFtZSA9ICdBeGlzJztcblxuZXhwb3J0IGRlZmF1bHQgQXhpcztcbiJdfQ==